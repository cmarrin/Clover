//
//  simple.Clover
//  Clover
//
//  Created by Chris Marrin on 5/25/24.
//

struct Simple
{

struct Float16
{
    // 16 bit float represented in an int16 as 1:1:14.
    // Can represent numbers from -1.9999 to 1.9999
    
    int16 _value;

    const uint8 BitsOfPrecision = 14;
    
    Float16(int16 v) { _value = v; }
    
    // Set value to integer part (i) and fraction part (f). Fraction part is
    // a 4 digit integer that is (conceptually) divided by 10000 to arrive
    // at the fraction. A value of 1 translates to 0.0001 and a value of
    // 1000 translates to a value of 0.1. A value greater than 9999 will
    // produce undefined results
    function setValue(int16 i, uint16 f)
    {
        _value = i + ((uint32(f) << BitsOfPrecision) / 10000);
    }
    
    // Add and subtract can be done as integers since no change in dp occurs
    function Float16 add(Float16 v) { return Float16(_value + v._value); }
    function Float16 sub(Float16 v) { return Float16(_value - v._value); }
    
    // multiply is done as a 32 bit integer multiply and then shifted right BitsOfPrecision bits
    function Float16 mul(Float16 v)
    {
        return Float16((int32(_value) * int32(v._value)) >> BitsOfPrecision);
    }
    
    // divide is done by shifting left BitsOfPrecision bits, then doing an integer divide
    function Float16 div(Float16 v)
    {
        return Float16((int32(_value) << BitsOfPrecision) / int32(v._value));
    }
    
    function toString(uint8* buf, uint8 size)
    {
        core.format(buf, size, "%d.%d\n", _value >> BitsOfPrecision, (_value & ((1 << BitsOfPrecision) - 1)) << 16 - BitsOfPrecision);
    }
};

function int32 main()
{
    Float16 a;
    Float16 b;
    Float16 c;
    
    a.setValue(1, 5000);
    b.setValue(3, 7000);
    c = a.add(b);
    
    uint8 buf[25];
    c.toString(buf, 25);
    core.printf("a + b = %s\n", buf);
    return 0;
}

};
